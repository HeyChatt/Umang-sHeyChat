<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HeyChat ‚Äî Full</title>

  <style>
    :root{
      --primary:#0078ff;--primary-dark:#005fcc;--bg:#f5f7fa;--surface:#fff;--text:#222;
      --sent:#d2eaff;--received:#ececec;--radius:12px;--transition:all .25s ease;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Poppins,Arial,sans-serif;background:var(--bg);color:var(--text);display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:20px;transition:var(--transition)}
    #themeToggle{position:fixed;top:15px;right:15px;background:var(--primary);color:#fff;border:none;border-radius:50%;width:40px;height:40px;font-size:18px;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.15)}
    #authSection{background:var(--surface);padding:22px;border-radius:var(--radius);box-shadow:0 2px 14px rgba(0,0,0,.06);max-width:360px;width:100%;text-align:center}
    #authSection input{width:100%;padding:10px;margin:8px 0;border:1px solid #ddd;border-radius:10px}
    #authSection button{width:48%;padding:10px;margin:6px 1%;border-radius:10px;border:none;background:var(--primary);color:#fff;cursor:pointer}
    #chatSection{display:none;width:100%;max-width:980px;background:var(--surface);border-radius:12px;padding:14px;box-shadow:0 2px 14px rgba(0,0,0,.06)}
    #workspace{display:flex;gap:12px}
    #usersPanel{width:240px;border:1px solid #eee;padding:10px;border-radius:10px;background:#fafafa;max-height:520px;overflow:auto}
    #usersPanel h3{margin-bottom:8px}
    #usersUl{list-style:none;padding:0;margin:0}
    .userItem{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;cursor:pointer}
    .userItem:hover{background:#f1f8ff}
    .userItem.active{background:#dfefff}
    .presence-dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px}
    .presence-online{background:#22c55e}.presence-offline{background:#cbd5e1}
    #messagesPanel{flex:1;display:flex;flex-direction:column}
    #messages{border:1px solid #ccc;height:420px;overflow:auto;padding:12px;border-radius:12px;background:var(--surface);display:flex;flex-direction:column;gap:8px}
    .message{padding:10px 14px;border-radius:12px;max-width:75%;word-wrap:break-word;display:flex;flex-direction:column;gap:6px}
    .sent{background:var(--sent);align-self:flex-end;text-align:right}
    .received{background:var(--received);align-self:flex-start;text-align:left}
    .meta{font-size:12px;color:#666}
    .controls{display:flex;gap:6px;justify-content:flex-end}
    .read-receipt{font-size:11px;color:#2a7cda;margin-top:4px;align-self:flex-end}
    #typingIndicator{font-size:13px;color:#666;min-height:18px;margin-top:6px}
    #chat-form{display:flex;gap:8px;margin-top:10px}
    #chat-form input{flex:1;padding:10px;border-radius:10px;border:1px solid #ddd}
    #chat-form button{padding:10px 16px;border-radius:10px;border:none;background:var(--primary);color:#fff;cursor:pointer}
    .logout-btn{background:#f44336;color:#fff;border:none;padding:8px 12px;border-radius:10px;cursor:pointer}
    @media(max-width:900px){#workspace{flex-direction:column}#usersPanel{width:100%;max-height:160px}#messages{height:340px}}
    /* dark */
    body.dark{background:#0d1117;color:#e6edf3}
    body.dark #messages{background:#0f1418;border-color:#2b3036}
    body.dark .sent{background:#1f6feb;color:#fff}
    body.dark .received{background:#2d333b;color:#e6edf3}
    body.dark input, body.dark button{background:#21262d;color:#e6edf3;border-color:#30363d}
  </style>
</head>
<body>
  <button id="themeToggle">üåô</button>

  <!-- AUTH -->
  <div id="authSection">
    <h2>Welcome to HeyChat üëã</h2>
    <input id="email" type="email" placeholder="Email" />
    <input id="password" type="password" placeholder="Password" />
    <div style="margin-top:8px">
      <button id="loginBtn">Login</button>
      <button id="signupBtn">Sign Up</button>
    </div>
  </div>

  <!-- CHAT -->
  <div id="chatSection">
    <h2 style="text-align:center;margin-bottom:8px">HeyChat üí¨</h2>
    <div id="workspace">
      <aside id="usersPanel">
        <h3>Users</h3>
        <div style="font-size:13px;color:#666;margin-bottom:8px">Click a user for private chat ‚Äî or Global</div>
        <ul id="usersUl"></ul>
        <hr style="margin:8px 0" />
        <button id="globalBtn" style="width:100%;padding:8px;border-radius:8px;border:none;background:#f1f5f9;cursor:pointer">üîä Global Chat</button>
      </aside>

      <section id="messagesPanel">
        <div id="messages"></div>
        <div id="typingIndicator"></div>

        <form id="chat-form">
          <input id="text" type="text" placeholder="Type a message..." autocomplete="off" />
          <button type="submit">Send</button>
        </form>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <button id="recordBtn">üéôÔ∏è Record</button>
          <button id="stopBtn" style="display:none">‚èπ Stop</button>
          <div id="recordStatus" style="font-size:13px;color:#666"></div>
        </div>
      </section>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
      <div id="signedAs" style="font-size:14px;color:#666"></div>
      <div>
        <button class="logout-btn" id="logoutBtn">Logout</button>
      </div>
    </div>
  </div>

  <!-- Firebase compat SDKs (non-module) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <!-- Main app script (deferred) -->
  <script defer>
  document.addEventListener('DOMContentLoaded', () => {
    // ---------- Firebase config (kept as provided) ----------
    const firebaseConfig = {
      apiKey: "AIzaSyAlVJcbUTlxZDd5oMUwvemk-FMiFneid80",
      authDomain: "heychat-1aea9.firebaseapp.com",
      projectId: "heychat-1aea9",
      storageBucket: "heychat-1aea9.appspot.com",
      messagingSenderId: "324327775275",
      appId: "1:324327775275:web:28ecebf9147b87d1655e6e"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();
    const rdb = firebase.database();

    // UI refs
    const emailEl = document.getElementById('email');
    const passEl = document.getElementById('password');
    const authSection = document.getElementById('authSection');
    const chatSection = document.getElementById('chatSection');
    const loginBtn = document.getElementById('loginBtn');
    const signupBtn = document.getElementById('signupBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const usersUl = document.getElementById('usersUl');
    const globalBtn = document.getElementById('globalBtn');
    const messagesEl = document.getElementById('messages');
    const chatForm = document.getElementById('chat-form');
    const textEl = document.getElementById('text');
    const signedAs = document.getElementById('signedAs');
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordStatus = document.getElementById('recordStatus');
    const typingIndicator = document.getElementById('typingIndicator');
    const themeToggle = document.getElementById('themeToggle');

    // state
    let currentChatId = 'global';
    let currentChatPartner = null;
    let messagesUnsub = null;
    let usersUnsub = null;
    let presenceListeners = {};
    let typingListenerRef = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let typingTimeout = null;

    // ---------- auth actions ----------
    async function setUsername(user) {
      const username = prompt('Choose a display name:');
      if (username && username.trim()) {
        await db.collection('users').doc(user.uid).set({
          username: username.trim(),
          email: user.email,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      } else {
        await db.collection('users').doc(user.uid).set({
          username: user.email.split('@')[0],
          email: user.email,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      }
    }

    signupBtn.addEventListener('click', async () => {
      const email = emailEl.value.trim();
      const pw = passEl.value.trim();
      if (!email || !pw) return alert('Enter email & password');
      try {
        const cred = await auth.createUserWithEmailAndPassword(email, pw);
        await setUsername(cred.user);
        alert('Signup OK ‚Äî you are signed in');
      } catch (err) {
        alert('Signup error: ' + err.message);
        console.error(err);
      }
    });

    loginBtn.addEventListener('click', async () => {
      try {
        await auth.signInWithEmailAndPassword(emailEl.value.trim(), passEl.value.trim());
      } catch (err) {
        alert('Login error: ' + err.message);
        console.error(err);
      }
    });

    logoutBtn.addEventListener('click', async () => {
      // set offline presence immediately
      const me = auth.currentUser;
      if (me) {
        const sref = rdb.ref('status/' + me.uid);
        sref.set({ online: false, lastSeen: Date.now() }).catch(()=>{});
      }
      await auth.signOut();
    });

    // ---------- presence (rdb) ----------
    function startPresence() {
      const me = auth.currentUser;
      if (!me) return;
      const statusRef = rdb.ref('status/' + me.uid);
      statusRef.set({ online: true, lastSeen: Date.now() }).catch(()=>{});
      // onDisconnect to set offline
      try {
        statusRef.onDisconnect().set({ online: false, lastSeen: Date.now() });
      } catch (e) {
        // ignore if onDisconnect not available
      }
    }

    function attachPresenceListener(uid) {
      if (presenceListeners[uid]) return;
      const ref = rdb.ref('status/' + uid);
      presenceListeners[uid] = ref.on('value', snap => {
        const el = document.getElementById('presence_' + uid);
        if (!el) return;
        const val = snap.val();
        if (val && val.online) {
          el.classList.remove('presence-offline'); el.classList.add('presence-online'); el.title = 'Online';
        } else {
          el.classList.remove('presence-online'); el.classList.add('presence-offline');
          if (val && val.lastSeen) el.title = 'Last seen: ' + (new Date(val.lastSeen)).toLocaleString();
          else el.title = 'Offline';
        }
      });
    }

    // ---------- load users ----------
    async function loadUsersList() {
      if (usersUnsub) usersUnsub();
      usersUl.innerHTML = '<li style="padding:8px;color:#666">Loading users...</li>';
      usersUnsub = db.collection('users').orderBy('createdAt').onSnapshot(snap => {
        usersUl.innerHTML = '';
        snap.forEach(doc => {
          const d = doc.data();
          const li = document.createElement('li');
          li.className = 'userItem';
          li.dataset.uid = doc.id;
          li.innerHTML = `<div style="display:flex;align-items:center"><span id="presence_${doc.id}" class="presence-dot presence-offline"></span><span>${d.username||d.email}</span></div><div style="font-size:12px;color:#666">${doc.id===auth.currentUser.uid?'You':''}</div>`;
          if (doc.id === auth.currentUser.uid) {
            li.style.opacity = 0.9;
          } else {
            li.addEventListener('click', () => openPrivateChat(doc.id, d.username || d.email));
          }
          usersUl.appendChild(li);
          attachPresenceListener(doc.id);
        });
      }, err => console.error('users list err', err));
    }

    // ---------- chat id helper ----------
    function makeChatId(a,b){ return a < b ? a + '_' + b : b + '_' + a; }

    // ---------- open private or global chat ----------
    async function openPrivateChat(partnerUid, partnerName) {
      currentChatId = makeChatId(auth.currentUser.uid, partnerUid);
      currentChatPartner = { uid: partnerUid, name: partnerName };
      document.querySelectorAll('.userItem').forEach(x=>x.classList.remove('active'));
      const li = [...document.querySelectorAll('.userItem')].find(i=>i.dataset.uid===partnerUid);
      if (li) li.classList.add('active');
      await db.collection('chats').doc(currentChatId).set({ participants: [auth.currentUser.uid, partnerUid], createdAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
      subscribeToMessages(currentChatId);
      subscribeTyping(currentChatId);
    }

    async function openGlobalChat() {
      currentChatId = 'global';
      currentChatPartner = null;
      document.querySelectorAll('.userItem').forEach(x=>x.classList.remove('active'));
      await db.collection('chats').doc('global').set({ createdAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
      subscribeToMessages('global');
      subscribeTyping('global');
    }
    globalBtn.addEventListener('click', openGlobalChat);

    // ---------- subscribe messages ----------
    function subscribeToMessages(chatId) {
      if (messagesUnsub) messagesUnsub();
      messagesEl.innerHTML = '<div style="color:#666;padding:8px">Loading messages...</div>';
      messagesUnsub = db.collection('chats').doc(chatId).collection('messages').orderBy('time').onSnapshot(snap => {
        messagesEl.innerHTML = '';
        snap.forEach(doc => {
          renderMessage(doc.id, doc.data());
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
        // viewer read -> update lastRead
        updateMyLastRead();
      }, err => console.error('messages sub err', err));
    }

    // ---------- render message ----------
    function renderMessage(id, msg) {
      const container = document.createElement('div');
      container.className = 'message ' + (msg.uid === auth.currentUser.uid ? 'sent' : 'received');
      const ms = msg.time && msg.time.seconds ? msg.time.seconds * 1000 : Date.now();
      container.dataset.timeMs = ms;

      const meta = document.createElement('div'); meta.className = 'meta';
      const ts = msg.time && msg.time.seconds ? new Date(msg.time.seconds*1000).toLocaleTimeString() : '';
      meta.textContent = `${msg.name || 'Anon'}${ts ? ' ‚Ä¢ ' + ts : ''}`;

      const content = document.createElement('div');
      if (msg.type === 'audio' && msg.audioUrl) {
        const a = document.createElement('audio'); a.controls = true; a.src = msg.audioUrl; content.appendChild(a);
      } else {
        content.textContent = msg.text || '';
      }

      container.appendChild(meta); container.appendChild(content);

      if (msg.uid === auth.currentUser.uid) {
        const controls = document.createElement('div'); controls.className = 'controls';
        if (msg.type === 'text') {
          const e = document.createElement('button'); e.textContent = '‚úèÔ∏è'; e.title = 'Edit';
          e.addEventListener('click', async () => {
            const nt = prompt('Edit message:', msg.text || '');
            if (nt !== null && nt.trim() !== '') {
              try { await db.collection('chats').doc(currentChatId).collection('messages').doc(id).update({ text: nt.trim() }); }
              catch(err){console.error(err)}
            }
          });
          controls.appendChild(e);
        }
        const d = document.createElement('button'); d.textContent='üóëÔ∏è'; d.title='Delete';
        d.addEventListener('click', async () => {
          if (confirm('Delete this message?')) {
            try { await db.collection('chats').doc(currentChatId).collection('messages').doc(id).delete(); }
            catch(err){console.error(err)}
          }
        });
        controls.appendChild(d);
        container.appendChild(controls);

        // read receipt placeholder
        const rr = document.createElement('div'); rr.className='read-receipt'; rr.textContent=''; container.appendChild(rr);
      }

      messagesEl.appendChild(container);
    }

    // ---------- send text ----------
    chatForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const text = textEl.value.trim();
      const user = auth.currentUser;
      if (!user || !text) return;
      try {
        const ud = await db.collection('users').doc(user.uid).get();
        const name = ud.exists ? ud.data().username : user.email;
        await db.collection('chats').doc(currentChatId).collection('messages').add({
          type: 'text', text, name, uid: user.uid,
          time: firebase.firestore.FieldValue.serverTimestamp()
        });
        textEl.value = '';
        // update lastRead
        await db.collection('chats').doc(currentChatId).collection('lastRead').doc(user.uid).set({ lastRead: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
        setTyping(false);
      } catch (err) { console.error(err) }
    });

    // ---------- typing indicator (rdb) ----------
    function setTyping(isTyping) {
      const me = auth.currentUser;
      if (!me || !currentChatId) return;
      const tRef = rdb.ref('typing/' + currentChatId + '/' + me.uid);
      if (isTyping) {
        tRef.set({ typing: true, ts: Date.now() }).catch(()=>{});
        if (typingTimeout) clearTimeout(typingTimeout);
        typingTimeout = setTimeout(()=> setTyping(false), 4000);
      } else {
        tRef.remove().catch(()=>{});
      }
    }
    textEl.addEventListener('input', () => {
      if (textEl.value && textEl.value.trim().length>0) setTyping(true);
      else setTyping(false);
    });

    function subscribeTyping(chatId) {
      // remove previous
      if (typingListenerRef) typingListenerRef.off && typingListenerRef.off();
      typingIndicator.textContent = '';
      const ref = rdb.ref('typing/' + chatId);
      typingListenerRef = ref;
      ref.on('value', async snap => {
        const v = snap.val();
        if (!v) { typingIndicator.textContent = ''; return; }
        const otherUids = Object.keys(v).filter(uid => uid !== (auth.currentUser && auth.currentUser.uid));
        if (otherUids.length === 0) { typingIndicator.textContent = ''; return; }
        // get up to 2 names
        const names = [];
        for (let i=0;i<Math.min(2, otherUids.length); i++) {
          try {
            const doc = await db.collection('users').doc(otherUids[i]).get();
            names.push(doc.exists ? doc.data().username : otherUids[i]);
          } catch(e){names.push(otherUids[i])}
        }
        typingIndicator.textContent = names.join(', ') + (otherUids.length>2 ? ' and more are typing...' : ' is typing...');
      });
    }

    // ---------- read receipts (lastRead) ----------
    let partnerLastReadUnsub = null;
    function subscribePartnerLastRead(partnerUid) {
      if (partnerLastReadUnsub) partnerLastReadUnsub();
      partnerLastReadUnsub = null;
      if (!partnerUid || partnerUid === 'global') return;
      const docRef = db.collection('chats').doc(currentChatId).collection('lastRead').doc(partnerUid);
      partnerLastReadUnsub = docRef.onSnapshot(snap => {
        const data = snap.exists ? snap.data() : null;
        applyReadReceipts(data && data.lastRead ? data.lastRead.toMillis ? data.lastRead.toMillis() : (data.lastRead.seconds*1000) : null);
      }, err => console.error(err));
    }

    function applyReadReceipts(ms) {
      const myMsgs = [...messagesEl.querySelectorAll('.message.sent')];
      myMsgs.forEach(node => {
        const tms = node.dataset.timeMs ? parseInt(node.dataset.timeMs,10) : 0;
        let rr = node.querySelector('.read-receipt');
        if (!rr) { rr = document.createElement('div'); rr.className='read-receipt'; node.appendChild(rr); }
        if (ms && tms && ms >= tms) rr.textContent = 'Seen';
        else rr.textContent = '';
      });
    }

    // ---------- upload & send voice ----------
    recordBtn.addEventListener('click', async () => {
      if (!auth.currentUser) return alert('Login to record.');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size>0) audioChunks.push(e.data); };
        mediaRecorder.onstart = () => {
          recordStatus.textContent = 'Recording...';
          recordBtn.style.display = 'none'; stopBtn.style.display = 'inline-block';
          setTyping(false);
        };
        mediaRecorder.onstop = async () => {
          recordStatus.textContent = '';
          recordBtn.style.display = 'inline-block'; stopBtn.style.display = 'none';
          const blob = new Blob(audioChunks, { type: 'audio/webm' });
          const name = `voice_${Date.now()}.webm`;
          const uid = auth.currentUser.uid;
          const path = `voices/${currentChatId}/${uid}_${name}`;
          const ref = storage.ref().child(path);
          try {
            await ref.put(blob);
            const url = await ref.getDownloadURL();
            const ud = await db.collection('users').doc(uid).get();
            const nameDisplay = ud.exists ? ud.data().username : auth.currentUser.email;
            await db.collection('chats').doc(currentChatId).collection('messages').add({
              type:'audio', audioUrl: url, name: nameDisplay, uid, time: firebase.firestore.FieldValue.serverTimestamp()
            });
            // update lastRead
            await db.collection('chats').doc(currentChatId).collection('lastRead').doc(uid).set({ lastRead: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
          } catch (err) { console.error('upload fail',err); alert('Upload failed: '+err.message) }
        };
        mediaRecorder.start();
      } catch (err) { alert('Mic error: ' + err.message); console.error(err) }
    });
    stopBtn.addEventListener('click', () => { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); });

    // ---------- helpers on auth change ----------
    auth.onAuthStateChanged(async user => {
      if (user) {
        authSection.style.display = 'none'; chatSection.style.display = 'block';
        signedAs.textContent = 'Signed in as ' + user.email;
        // start presence & load users & open global chat
        startPresence();
        loadUsersList();
        await openGlobalChat();
      } else {
        authSection.style.display = 'block'; chatSection.style.display = 'none';
        signedAs.textContent = '';
        // cleanup listeners
        if (messagesUnsub) messagesUnsub(); messagesUnsub = null;
        if (usersUnsub) usersUnsub(); usersUnsub = null;
        if (typingListenerRef) typingListenerRef.off && typingListenerRef.off();
      }
    });

    // update lastRead when viewing
    messagesEl.addEventListener('scroll', debounce(()=> updateMyLastRead(), 600));
    document.addEventListener('visibilitychange', ()=> { if (document.visibilityState === 'visible') updateMyLastRead(); });

    async function updateMyLastRead() {
      const me = auth.currentUser; if (!me || !currentChatId) return;
      try {
        await db.collection('chats').doc(currentChatId).collection('lastRead').doc(me.uid).set({ lastRead: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
      } catch (e) { console.error(e) }
    }

    // debounce util
    function debounce(fn, wait){ let t; return function(...a){ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), wait); } }

    // ---------- theme toggle (persist) ----------
    if (localStorage.getItem('theme') === 'dark') { document.body.classList.add('dark'); themeToggle.textContent='‚òÄÔ∏è'; }
    themeToggle.addEventListener('click', ()=> {
      document.body.classList.toggle('dark'); const is = document.body.classList.contains('dark'); localStorage.setItem('theme', is ? 'dark' : 'light'); themeToggle.textContent = is ? '‚òÄÔ∏è' : 'üåô';
    });

    // ---------- helper: subscribeTyping wrapper ----------
    function subscribeTyping(chatId) {
      if (typingListenerRef && typingListenerRef.off) typingListenerRef.off();
      typingIndicator.textContent = '';
      const ref = rdb.ref('typing/' + chatId);
      typingListenerRef = ref;
      ref.on('value', async snap => {
        const v = snap.val();
        if (!v) { typingIndicator.textContent = ''; return; }
        const other = Object.keys(v).filter(uid => uid !== (auth.currentUser && auth.currentUser.uid));
        if (other.length === 0) { typingIndicator.textContent = ''; return; }
        const names = [];
        for (let i=0;i<Math.min(2,other.length);i++) {
          try { const ud = await db.collection('users').doc(other[i]).get(); names.push(ud.exists ? ud.data().username : other[i]); } catch(e){names.push(other[i])}
        }
        typingIndicator.textContent = names.join(', ') + (other.length>2 ? ' and more are typing...' : ' is typing...');
      });
    }

    // ---------- expose some helpers to console for debugging ----------
    window.heychat = {
      auth, db, rdb, storage,
      openGlobalChat, openPrivateChat
    };
  });
  </script>
</body>
        </html>
